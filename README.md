Mini State Manager (vanilla JS)

Минималистичный менеджер состояния, созданный на чистом JavaScript без зависимостей.
Подходит для небольших проектов, обучения архитектуре и понимания принципов Redux/MobX.

Этот проект — пошаговая реализация собственного state-manager’a, который можно использовать в приложениях, основанных на подписках и реактивных обновлениях DOM.

# Цель — получить простое, предсказуемое, управляемое состояние, которое обновляет UI автоматически и централизованно.

Этот менеджер создан как обучающий и практичный инструмент, который:
- показывает принципы больших библиотек (Redux, Zustand, MobX);
- избавляет от лишней сложности;
- даёт полный контроль над тем, как работает состояние;
- легко расширяется собственными идеями.

Он идеально подходит, чтобы прочувствовать на практике архитектуру state-management’а.


# Главные принципы:
1) Единое хранилище — источник истины для всего приложения
2) Явные обновления — состояние меняется только через одну точку
3) Подписки на изменения — UI реагирует автоматически
4) Мини-middleware — тонкая точка расширения (логирование, валидация, модификация)
5) Чистый JS, никакой магии — прозрачная, лёгкая в понимании архитектура

# Единое хранилище данных

Состояние хранится в замыкании и доступно только через методы.

Пример использования:
```const store = createStore({ tasks: [] });```

# Чтение состояния
```store.getState();```

# Обновление состояния
```store.setState({x: 2});```
```store.setState(prevState => ({...prevState, y: 2}));```

# Подписки
```
const unsubscribe = store.subscribe(() => {
  render();
});
```

# Отписки
```unsubscribe();```

# Мини-middleware

Можно перехватывать обновления:

```
store.use(next => update => {
  console.log("Обновление:", update.toString());
  next(update);
});
```

# Логирование
Автоматический вывод всех изменений в консоль, реализован через middleware.

# Как это работает внутри?

1) состояние находится в приватной области (замыкание)
2) subscribe() добавляет функцию в список слушателей
3) update() вызывает middleware → обновляет состояние → уведомляет слушателей
4) подписчики запускают render или любую другую логику
5) UI всегда отражает актуальное состояние

# План развития

1) атомарные хранилища (несколько store'ов)
2) селекторы
3) мемоизация подписок
4) батчинг обновлений
5) встроенная история изменений (undo/redo)
6) DevTools-панель